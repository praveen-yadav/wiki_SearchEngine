In [[object-oriented programming]], a '''class''' is a construct that is used to define a distinct [[data type|type]]. The class is instantiated into [[Instance (computer science)|instance]]s of itself – referred to as ''class instances'', ''class objects'', ''instance objects'' or simply ''[[Object (object-oriented programming)|object]]s''. A class defines constituent members that enable its instances to have state and behavior.{{sfn|Gamma, Helm, Johnson, Vlissides|1995| p=14}} Data field members (''member variables'' or ''instance variables'') enable a class instance to maintain state. Other kinds of members, especially ''[[Method (computer programming)|method]]s'', enable the behavior of class instances. Classes therefore define the [[data type|type]] of their instances.{{sfn|Gamma et al.|1995| p=17}} 

A class usually represents a noun, such as a person, place or thing, or something [[Nominalization|nominalized]]. For example, a "Banana" class would represent the properties and functionality of bananas in general. A single, particular banana would be an instance of the "Banana" class, an object of the type "Banana".

== Design and implementation ==
Classes are composed from structural and behavioral constituents.{{sfn|Gamma et al.|1995| p=14}}  <!-- though there may not be a requirement to include any constituents at all--> Programming languages that include classes as a programming construct offer support for various class-related features, and the syntax required to use these features varies greatly from one programming language to another.

=== Structure ===
[[File:oop-uml-class-example.png|frame|right|[[Unified Modeling Language|UML]] notation for classes]]

A class contains [[Data (computing)|data]] field descriptions (or ''properties'', ''fields'', ''data members'', or ''attributes''). These are usually field types and names that will be associated with state variables at program run time; these state variables either belong to the class or specific instances of the class. In most languages, the structure defined by the class determines the layout of the memory used by its instances. Other implementations are possible: for example, objects in [[Python (programming language)|Python]] use associative key-value containers.<ref name="pythondata model">{{cite web|url=http://docs.python.org/reference/datamodel.html|title=3. Data model|work=The Python Language Reference|publisher=Python Software Foundation|accessdate=2012-04-26}}</ref> 

Some programming languages support specification of [[class invariant|invariant]]s as part of the definition of the class, and enforce them through the type system. [[Encapsulation (object-oriented programming)|Encapsulation]] of state is necessary for being able to enforce the invariants of the class.

=== Behavior ===
{{Main|Method (computer programming)}}
<!-- This section used to contain info on Java interfaces. If you wish to view it (to, say, move to another page), the last revision before the removal of this info is http://en.wikipedia.org/w/index.php?title=Class_(computer_science)&oldid=165562113 -->

The behavior of class or its instances is defined using [[Method (computer programming)|methods]]. Methods are [[subroutine]]s with the ability to operate on objects or classes. These operations may alter the state of an object or simply provide ways of accessing it.{{sfn|Booch|1994| p=86-88}} <!-- (Note: Some languages allow direct access to instance variables ([[C++]])). --> Many kinds of methods exist, but support for them varies across languages. Some types of methods are created and called by programmer code, while other special methods—such as constructors, destructors, and conversion operators—are created and called by compiler-generated code. A language may also allow the programmer to define and call these special methods.<ref>{{cite web|url=http://www.cplusplus.com/doc/tutorial/classes/|title=Classes (I)|work=C++ Language Tutorial|publisher=cplusplus.com|accessdate=2012-04-29}}</ref><ref>{{cite web|url=http://www.cplusplus.com/doc/tutorial/classes2/|title=Classes (II)|work=C++ Language Tutorial|publisher=cplusplus.com|accessdate=2012-04-29}}</ref>

=== The concept of class interface ===
{{Main|Interface (computing)}}
Every class '''implements''' (or ''realizes'') an interface by providing [[#Structure|structure]] and behavior. Structure consists of data and state, and behavior consists of code that specifies how methods are implemented.{{sfn|Booch|1994|p=105}} There is a distinction between the definition of an interface and the implementation of that interface; however, this line is blurred in many programming languages because class declarations both define and implement an interface. Some languages, however, provide features that separate interface and implementation. For example, an [[#Abstract_and_Concrete|abstract class]] can define an interface without providing implementation.

Languages that support class inheritance also allow classes to inherit interfaces from the classes that they are derived from.{{example needed}} In languages that support [[#Information hiding and encapsulation|access specifiers]], the interface of a class is considered to be the set of public members of the class, including both methods and attributes (via implicit [[Mutator method|getter and setter methods]]); any private members or internal data structures are not intended to be depended on by external <!--client--> code and thus are not part of the interface.

Object-oriented programming methodology <!--is designed in such a way--> dictates that the operations of any interface of a class are to be independent of each other. It results in a layered design where clients of an interface use the methods declared in the interface. An interface places no requirements for clients to invoke the operations of one interface in any particular order. This approach has the benefit that client code can assume that the operations of an interface are available for use whenever the client <!--holds a valid reference--> has access to the object. {{Citation needed|reason=Source needed for whole paragraph...this is a rather specific statement about OOP methodology.|date=April 2012}}

==== Example ====
The buttons on the front of your television set are the interface between you and the electrical wiring on the other side of its plastic casing. You press the "power" button to toggle the television on and off. In this example, your particular television is the instance, each method is represented by a button, and all the buttons together comprise the interface. (Other television sets that are the same model as yours would have the same interface.) In its most common form, an interface is a specification of a group of related methods without any associated implementation of the methods.

A television set also has a myriad of ''attributes'', such as size and whether it supports color, which together comprise its structure. A class represents the full description of a television, including its attributes (structure) and buttons (interface).

Getting the total number of televisions manufactured could be a ''static method'' of the television class. This method is clearly associated with the class, yet is outside the domain of each individual instance of the class. Another example would be a static method that finds a particular instance out of the set of all television objects.

=== Member accessibility ===
{{redirects here|Private member|other uses|Private members club|other uses|Private member's bill}}
{{Further|Information hiding}}

Many languages support the concept of '''information hiding''' and '''encapsulation''', typically with '''access specifiers''' for class members. Access specifiers control access to class members. Some access specifiers may also control how classes inherit such constraints. Their primary purpose is to separate the interface of a class from its implementation.

The following is a common set of access specifiers:<ref name="JavaAccessControl">{{cite web| url=http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html|title=Controlling Access to Members of a Class|work=The Java Tutorials|publisher=Oracle|accessdate=2012-04-19}}</ref>

* '''private''' (or ''class-private'') restricts the access to the class itself. Only methods that are part of the same class can access private members.
* '''protected''' (or ''class-protected'') allows the class itself and all its subclasses to access the member.
* '''public''' means that any code can access the member by its name.

Although many object-oriented languages support the above access specifiers, <!-- {{Citation needed|reason=This is fairly obvious, but it needs to be cited--could even use a few links even to articles within Wikipedia.|date=April 2012}} -->their semantics may differ.

Object-oriented design uses the access specifiers in conjunction with careful design of public method implementations to enforce class invariants—constraints on the state of the objects. A common usage of access specifiers is to separate the internal data of a class from its interface: the internal structure is made private, while public [[accessor method]]s can be used to inspect or alter such private data.

Access specifiers do not necessarily control '''visibility''', in that even private members may be visible to client external code. In some languages, an inaccessible but visible member may be referred to at run-time (for example, by a pointer returned from a member function), but an attempt to use it by referring to the name of the member from client code will be prevented by the type checker.<ref>{{cite web|url=https://www.securecoding.cert.org/confluence/display/cplusplus/OOP35-CPP.+Do+not+return+references+to+private+data|title=OOP35-CPP. Do not return references to private data|work=CERT C++ Secure Coding Standard|publisher=Carnegie Mellon University|date=2010-05-10|accessdate=2012-05-07}}</ref>

The various object-oriented programming languages enforce member accessibility and visibility to various degrees, and depending on the language's [[type system]] and compilation policies, enforced at either [[Compile time|compile-time]] or [[Run time (program lifecycle phase)|run-time]]. For example, the [[Java (programming language)|Java]] language does not allow client code that accesses the private data of a class to compile.
<ref>{{cite web|url=http://introcs.cs.princeton.edu/java/11cheatsheet/errors.pdf|title=2.2 Identifiers|work=Compile and Runtime Errors in Java|first=Mordechai|last=Ben-Ari|date=2007-01-24|accessdate=2012-05-07}}</ref> <!-- whereas in languages like [[Objective-C]] or [[Perl]] client code is not restricted.--> In the [[C++]] language, private methods are visible, but not accessible in the interface; however, they may be made invisible by explicitly declaring fully abstract classes that represent the interfaces of the class.<ref name="cppinterface">{{cite web|url=http://www.drdobbs.com/cpp/184410630|title=C++ Interfaces|last=Wild|first=Fred|work=Dr. Dobb's|publisher=UBM Techweb|accessdate=2012-05-02}}</ref> 

Some languages feature other accessibility schemes:
* '''Instance vs. class accessibility''': [[Ruby (programming language)|Ruby]] supports '''instance-private''' and '''instance-protected''' access specifiers in lieu of class-private and class-protected, respectively. They differ in that they restrict access based on the instance itself, rather than the instance's class.<ref>{{cite web
 | url=http://ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html
 | title=Classes, Objects, and Variables|work=Programming Ruby: The Pragmatic Programmer's Guide
 | last=Thomas
 | last2=Hunt
 | publisher=Ruby-Doc.org
 | accessdate=2012-04-26}}
</ref>

* '''Friend''': C++ supports a mechanism where a function explicitly declared as a [[friend function]] of the class may access the members designated as private or protected.<ref>{{cite web|url=http://www.cplusplus.com/doc/tutorial/inheritance/
|title=Friendship and inheritance|work=C++ Language Tutorial|publisher=cplusplus.com|accessdate=2012-04-26}}</ref>

* '''Path-based''': Java supports restricting access to a member within a [[Java syntax#Access modifiers|Java package]], which is the logical path of the file.  However, it is a common practice when extending a Java framework to implement classes in the same package as a framework class in order to access protected members.  The source file may exist in a completely different location, and may be deployed to a different .jar file, yet still be in the same logical path as far as the JVM is concerned.<ref name=JavaAccessControl />

== Inter-class relationships ==
In addition to the design of standalone classes, programming languages may support more advanced class design based upon relationships between classes. The inter-class relationship design capabilities commonly provided are ''compositional'' and ''hierarchical''.

=== Compositional ===
Classes can be composed of other classes, thereby establishing a compositional relationship between the enclosing class and its embedded classes. Compositional relationship between classes is also commonly known as a '''[[has-a]]''' relationship.{{sfn|Booch|1994| p=180}} For example, a class "Car" could be composed of and contain a class "Engine". Therefore, a Car '''has an''' Engine. One aspect of composition is containment, which is the enclosure of component instances by the instance that has them. If an enclosing object contains component instances by value, the components and their enclosing object have a similar [[Object lifetime|lifetime]]. If the components are contained by reference, they may not have a similar lifetime.{{sfn|Booch|1994| p=128-129}} For example, in Objective-C 2.0:

<source lang="objc">
@interface Car : NSObject

@property NSString *name;
@property Engine *engine
@property NSArray *tyres;

@end
</source>

This <code>Car</code> class '''has''' an instance of <code>NSString</code> (string object), <code>Engine</code>, and <code>NSArray</code> (array object).

=== Hierarchical ===
Classes can be ''derived'' from one or more existing classes, thereby establishing a hierarchical relationship between the derived-from classes (''base classes'', ''parent classes'' or ''superclasses'') and the derived class (''child class'' or ''subclass'') . The relationship of the derived class to the derived-from classes is commonly known as an '''[[is-a]]''' relationship.{{sfn|Booch|1994| p=112}} For example, a class 'Button' could be derived from a class 'Control'. Therefore, a Button '''is a''' Control. Structural and behavioral members of the parent classes are ''inherited'' by the child class. Derived classes can define additional structural members (data fields) and/or behavioral members (methods) in addition to those that they ''inherit'' and are therefore ''specializations'' of their superclasses. Also, derived classes can [[method overriding|override]] inherited methods if the language allows.

Not all languages support multiple inheritance. For example, Java allows a class to implement multiple interfaces, but only inherit from one class.<ref name="javainterface">{{cite web| url=http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html|title=Interfaces|work=The Java Tutorials|publisher=Oracle|accessdate=2012-05-01}}</ref> If multiple inheritance is allowed, the hierarchy is a [[directed acyclic graph]] (or DAG for short), otherwise it is a [[tree (graph theory)|tree]]. The hierarchy has classes as nodes and inheritance relationships as links. Classes in the same level are more likely to be [[association (object-oriented programming)|associated]] than classes in different levels. The levels of this hierarchy are called [[Layer (object-oriented design)|layers]] or [[level of abstraction|levels of abstraction]].

Example (Simplified Objective-C 2.0 code, from iPhone SDK):
<source lang="objc">
@interface UIResponder : NSObject //...
@interface UIView : UIResponder //...
@interface UIScrollView : UIView //...
@interface UITableView : UIScrollView //...
</source>
In this example, a UITableView '''is a''' UIScrollView '''is a''' UIView '''is a''' UIResponder '''is an''' NSObject.

==== Definitions of subclass <!-- some of this applies, but most belongs in an OO article --> ====
{{Main|Inheritance (object-oriented programming)|Superclass (computer science)|Subclass (computer science)}}

{{Unreferenced section|date=May 2012}}

Conceptually, a superclass should be considered as a common part of its subclasses. This factoring of commonality is one mechanism for providing [[Code reuse|reuse]]. Thus, extending a superclass by modifying the existing class is also likely to narrow its applicability in various situations. In object-oriented design, careful balance between applicability and functionality of superclasses should be considered. Subclassing is different from [[subtyping]] in that subtyping deals with common behavior whereas subclassing is concerned with common structure.

There are two different points of view as to whether subclasses of the same class are required to be disjoint. Sometimes, subclasses of a particular class are considered to be completely disjoint. That is, every instance of a class has exactly one ''most-derived class'', which is a subclass of every class that the instance has. This view does not allow dynamic change of object's class, as objects are assumed to be created with a fixed most-derived class. The basis for not allowing changes to object's class is that the class is a compile-time type, which does not usually change at runtime, and [[Polymorphism in object-oriented programming|polymorphism]] is utilized for any dynamic change to the object's behavior, so this ability is not necessary. Design that does not need to perform changes to object's type will be more robust and easy-to-use from the point of view of the users of the class. 

From another point of view, subclasses are not required to be disjoint. Then there is no concept of a most-derived class, and all types in the inheritance hierarchy that are types of the instance are considered to be equally types of the instance. This view is based on a dynamic classification of objects, such that an object may change its class at runtime. Then object's class is considered to be its ''current'' structure, but changes to it are allowed. The basis for allowing changes to object's class is a perceived inconvenience caused by replacing an instance with another instance of a different type, since this would require change of all references to the original instance to be changed to refer to the new instance. When changing the object's class, references to the existing instances do not need to be replaced with references to new instances when the class of the object changes. However, this ability is not readily available in all programming languages. This analysis depends on the proposition that dynamic changes to object structure are common. This may or may not be the case in practice.

=== Orthogonality of the class concept and inheritance ===
Although class-based languages are commonly assumed to support inheritance, inheritance is not an intrinsic aspect of the concept of classes. Some languages, often referred to as "[[object-based languages]]", support classes yet do not support inheritance. Examples of object-based languages include earlier versions of [[Visual Basic]].<!-- do not provide the structural benefits of statically type-checked interfaces for objects. This is because in object-based languages, it is possible to use and extend data structures and attach methods to them at run-time. This precludes the compiler or interpreter being able to check the type information specified in the source code as the type is built dynamically and not defined statically. Most of these languages allow for ''instance behavior'' and complex ''operational polymorphism'' (see [[dynamic dispatch]] and [[Polymorphism (computer science)|polymorphism]]). -->

=== Within object-oriented analysis <!-- belongs in an Object-Oriented Analysis article--> ===
{{Main|Association (object-oriented programming)}}<!--consider moving a bunch of stuff here to this page...-->

In [[object-oriented analysis]] and in [[Unified Modelling Language|UML]], an '''association''' between two classes represents a collaboration between the classes or their corresponding instances. Associations have direction; for example, a bi-directional association between two classes indicates that both of the classes are aware of their relationship.<ref name="ibmuml">{{cite web| url=http://www.ibm.com/developerworks/rational/library/content/RationalEdge/sep04/bell/|title=UML Basics: The class diagram|last=Bell|first=Donald|work=developer Works|publisher=IBM|accessdate=2012-05-02}}</ref> Associations may be labeled according to their name or purpose.{{sfn|Booch|1994| p=179}}

An association role is given end of an association and describes the role of the corresponding class. For example, a "subscriber" role describes the way instances of the class "Person" participate in a "subscribes-to" association with the class "Magazine". Also, a "Magazine" has the "subscribed magazine" role in the same association. Association role multiplicity describes how many instances correspond to each instance of the other class of the association. Common multiplicities are "0..1", "1..1", "1..*" and "0..*", where the "*" specifies any number of instances.<ref name=ibmuml />

== Taxonomy of classes ==
There are many categories of classes; however, these categories do not necessarily divide classes into distinct partitions.

=== Abstract and concrete {{anchor|Abstract_and_concrete_classes}} {{anchor|Abstract_and_Concrete}} ===
{{Main|Abstract type}}

In a language that supports inheritance, an '''abstract class''', or ''abstract base class'' (ABC), is a class that cannot be instantiated because it is either labeled as abstract or it simply specifies [[abstract method]]s (or ''virtual methods''). Abstract classes specify virtual methods via [[Type signature|signatures]] that are to be implemented by direct or indirect descendents of the abstract class. Before a class derived from an abstract class can be instantiated, all abstract methods of its parent classes must be implemented by some class in the derivation chain.<ref name="cpppoly">{{cite web|url=http://www.cplusplus.com/doc/tutorial/polymorphism/
|title=Polymorphism|work=C++ Language Tutorial|publisher=cplusplus.com|accessdate=2012-05-02}}</ref>

Most object oriented programming languages allow the programmer to specify which classes are considered abstract and will not allow these to be instantiated. For example, in [[Java (programming language)|Java]] and [[PHP]], the keyword ''abstract'' is used.<ref>{{cite web| url=http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html|title=Abstract Methods and Classes|work=The Java Tutorials|publisher=Oracle|accessdate=2012-05-02}}</ref><ref>{{cite web|url=http://php.net/manual/en/language.oop5.abstract.php|title=Class Abstraction|work=PHP Manual|publisher=The PHP Group|accessdate=2012-05-02}}</ref> In [[C++]], an abstract class is a class having at least one abstract method given by the appropriate syntax in that language (a pure virtual function in C++ parlance).<ref name=cpppoly /> 

A class consisting of only virtual methods is called a Pure Abstract Base Class (or ''Pure ABC'') in C++ and is also known as an ''interface'' by users of the language.<ref name=cppinterface /> Other languages, notably Java and C#, support a variant of abstract classes called an [[Interface (Java)|interface]] via a keyword in the language. In these languages, [[multiple inheritance]] is not allowed, but a class can implement multiple interfaces. Such a class can only contain abstract publicly accessible methods.
<ref name=javainterface />
<ref>{{cite web
 | url=http://msdn.microsoft.com/en-us/library/ms173156.aspx
 | title=Interfaces (C# Programming Guide)
 | work=C# Programming Guide
 | publisher=Microsoft
 | accessdate=2013-08-15}}
</ref>
<ref>{{cite web
 | url=http://msdn.microsoft.com/en-us/library/ms173149.aspx
 | title=Inheritance (C# Programming Guide)
 | work=C# Programming Guide
 | publisher=Microsoft
 | accessdate=2012-05-02}}
</ref> 
<!--Abstract classes defined as interfaces are a much more specific usage of the more general meaning of the term ''interface'', even as used in computer science, and the concept of interfaces has seen much usage and popularity within the realm of languages that support object-orientation.-->

A '''concrete class''' is a class that can be [[Instantiation (computer science)|instantiated]], as opposed to abstract classes, which cannot. <!-- (In "Advanced C++ Programming Styles and Idioms", James Coplien defines "concrete class" as a class that has implicitly generated or explicitly defined special member functions that enable a class object to behave as do built-in types. These "concrete classes", then, adhere to the "Orthodox Canonical Form". Many developers who first learned the term as such, way back then, still primarily use it that way). -->

=== Local and inner ===
In some languages, classes can be declared in [[Scope (programming)|scopes]] other than the global scope. There are various types of such classes.

An '''[[Inner class]]'''  is a class defined within another class. The relationship between an inner class and its containing class can also be treated as another type of class association. An inner class is typically neither associated with instances of the enclosing class nor instantiated along with its enclosing class. Depending on language, it may or may not be possible to refer to the class from outside the enclosing class. A related concept is ''inner types'', also known as ''inner data type'' or ''nested type'', which is a generalization of the concept of inner classes. [[C++]] is an example of a language that supports both inner classes and inner types (via ''[[typedef]]'' declarations).
<ref>{{cite web
 | url=http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr061.htm
 | title=Nested classes (C++ only)
 | work=XL C/C++ V8.0 for AIX
 | publisher=IBM
 | accessdate=2012-05-07
}}
</ref>
<ref>{{cite web
 | url=http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr063.htm
 | title=Local type names (C++ only)
 | work=XL C/C++ V8.0 for AIX
 | publisher=IBM
 | accessdate=2012-05-07
}}
</ref>

Another type is a '''local class''', which is a class defined within a procedure or function. This limits references to the class name to within the scope where the class is declared. Depending on the semantic rules of the language, there may be additional restrictions on local classes compared non-local ones. One common restriction is to disallow local class methods to access local variables of the enclosing function. For example, in C++, a local class may refer to static variables declared within its enclosing function, but may not access the function's automatic variables.
<ref>{{cite web
 | url=http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr062.htm
 | title=Local classes (C++ only)
 | work=XL C/C++ V8.0 for AIX
 | publisher=IBM
 | accessdate=2012-05-07
}}
</ref>

=== Metaclasses ===
{{Main|Metaclass}}

'''Metaclasses''' are classes whose instances are classes.{{sfn|Booch|1994|p=133-134}} A metaclass describes a common structure of a collection of classes and can implement a [[design pattern (computer science)|design pattern]] or describe particular kinds of classes. Metaclasses are often used to describe [[software framework|framework]]s.{{Citation needed|date=May 2012}}

In some languages, such as [[Python (programming language)|Python]], [[Ruby (programming language)|Ruby]] or [[Smalltalk]], a class is also an object; thus each class is an instance of a unique metaclass which is built into the language.
<ref name="pythondata model" />
<ref>{{cite web
 | url=http://www.ruby-doc.org/docs/ProgrammingRuby/html/classes.html
 | title=Classes and Objects
 | work=Programming Ruby: The Pragmatic Programmer's Guide
 | last=Thomas
 | last2=Hunt
 | publisher=Ruby-Doc.org
 | accessdate=2012-05-08}}
</ref>
{{sfn|Booch|1994|p=134}}
For example, in [[Objective-C]], each object and class is an instance of NSObject.
<ref>{{cite web
 | url=https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/nsobject_Class/Reference/Reference.html
 | title=NSObject Class Reference
 | work=Mac OS X Developer Library
 | publisher=Apple
 | accessdate=2012-05-08}}
</ref>
The [[Common Lisp Object System]] (CLOS) provides [[Metaobject|metaobject protocols]] (MOPs) to implement those classes and metaclasses.
<ref>{{cite web
 | url=http://www.alu.org/mop/concepts.html#introduction
 | title=MOP: Concepts
 | work=The Common Lisp Object System MetaObject Protocol
 | publisher=Association of Lisp Users
 | accessdate=2012-05-08}}
</ref>

=== Non-subclassable ===
Non-subclassable classes allow programmers to design classes and hierarchies of classes which at some level in the hierarchy, further derivation is prohibited. (A stand-alone class may be also designated as non-subclassable, preventing the formation of any hierarchy). Contrast this to ''abstract'' classes, which imply, encourage, and require derivation in order to be used at all. A non-subclassable class is implicitly ''concrete''. 

A non-subclassable class is created by declaring the class as <code>sealed</code> in C# or as <code>final</code> in Java.
<ref>{{cite web
 | url=http://msdn.microsoft.com/en-us/library/ms173149.aspx
 | title=sealed (C# Reference)
 | work=C# Reference
 | publisher=Microsoft
 | accessdate=2012-05-08}}
</ref> 
<ref>{{cite web
 | url=http://docs.oracle.com/javase/tutorial/java/IandI/final.html
 | title=Writing Final Classes and Methods
 | work=The Java Tutorials
 | publisher=Oracle
 | accessdate=2012-05-08}}
</ref>
For example, Java's {{Java|String}} class is designated as ''final''. 
<ref>{{cite web
 | url=http://docs.oracle.com/javase/7/docs/api/java/lang/String.html
 | title=String (Java Platform SE 7)
 | work=Java Platform, Standard Edition 7: API Specification
 | publisher=Oracle
 | accessdate=2012-05-08}}
</ref>

Non-subclassable classes may allow a compiler (in compiled languages) to perform optimizations that are not available for subclassable classes.{{Citation needed|date=May 2012}}

<!-- The following goes without saying, i.e., it says nothing but to hint that "abstract" and "concrete" are an "either but not both" concept. 'abstract' and 'concrete' are defined already above.--> 
<!-- While it is impossible in any object-oriented language to have a class that is both abstract and concrete, -->
<!-- it may be possible to have an abstract partial class -->
<!-- The following seemingly belongs in the 'method' article -->
<!-- It is also possible not to declare the whole class as such, but only the [[Override (object-oriented programming)|override]] as sealed. This classes are used because of efficiency concerns (can be called like static classes) and security (avoids inadvertent modification of the class semantics).<ref>
{{cite web
| accessdate = 2011-08-03
| date       = 2002-03-25
| first      = Hanspeter
| last       = Mössenböck
| location   = http://ssw.jku.at/Teaching/Lectures/CSharp/Tutorial/
| page       = 17
| publisher  = Institut für Systemsoftware, Johannes Kepler Universität Linz, Fachbereich Informatik
| title      = Advanced C#: Overriding of Methods
| url        = http://ssw.jku.at/Teaching/Lectures/CSharp/Tutorial/Part2.pdf}}
</ref> -->

=== Partial ===
{{Unreferenced section|date=April 2012}}

In languages supporting the feature, a '''partial class''' is a class whose definition may be split into multiple pieces, within a single [[source code|source-code]] file or across multiple files. The pieces are merged at compile-time, making compiler output the same as for a non-partial class.

The primary motivation for introduction of partial classes is to facilitate the implementation of [[code generator]]s, such as [[visual designer]]s. It is otherwise a challenge or compromise to develop code generators that can manage the generated code when it is interleaved within developer-written code. Using partial classes, a code generator can process a separate file or coarse-grained partial class within a file, and is thus alleviated from intricately interjecting generated code via extensive parsing, increasing compiler efficiency and eliminating the potential risk of corrupting developer code. In a simple implementation of partial classes, the compiler can perform a phase of [[precompilation]] where it "unifies" all the parts of a partial class. Then, compilation can proceed as usual.

Other benefits and effects of the partial class feature include:

* Enables separation of a class's interface and implementation code in a unique way.
* Eases navigation through large classes within an [[source code editor|editor]].<!-- Large classes should be avoided, but with code generation for GUIs and such, it is inevitable.-->
* Enables [[separation of concerns]], in a way similar to [[aspect-oriented programming]] but without using any extra tools.
* Enables multiple developers to work on a single class concurrently without the need to merge individual code into one file at a later time. <!-- (This enabling may be considered by some or most to be a detriment rather than a benefit for SoC can apply to programmers also).-->

Partial classes have existed in [[Smalltalk]] under the name of ''Class Extensions'' for considerable time. With the arrival of the [[.NET Framework|.NET framework 2]], [[Microsoft]] introduced partial classes, supported in both [[C Sharp (programming language)|C#]] 2.0 and [[Visual Basic .NET|Visual Basic 2005]]. [[WinRT]] also supports partial classes.

==== Example in VB.NET ====
This simple example, written in [[Visual Basic .NET]], shows how parts of the same class are defined in two different files.
;file1.vb:
<source lang="vbnet">
Partial Class MyClass
    Private _name As String
End Class
</source>
;file2.vb:
<source lang="vbnet">
Partial Class MyClass
    Public Readonly Property Name() As String
         Get
             Return _name
         End Get
    End Property
End Class
</source>
When compiled, the result is the same as if the two files were written as one, like this:
<source lang="vbnet">
Class MyClass
    Private _name As String
    Public Readonly Property Name() As String
         Get
             Return _name
         End Get
    End Property
End Class
</source>

==== Example in Objective-C ====
In [[Objective-C]], partial classes, aka '''categories''' may even spread over multiple libraries and executables, like this example:

In Foundation, header file NSData.h:
<source lang="objc">
@interface NSData : NSObject

- (id)initWithContentsOfURL:(NSURL *)URL;
//...

@end
</source>
In user-supplied library, a separate binary from Foundation framework, header file NSData+base64.h:
<source lang="objc">
#import <Foundation/Foundation.h>

@interface NSData (base64)

- (NSString *)base64String;
- (id)initWithBase64String:(NSString *)base64String;

@end
</source>
And in an app, yet another separate binary file, source code file main.m:
<source lang="objc">
#import <Foundation/Foundation.h>
#import "NSData+base64.h"

int main(int argc, char *argv[])
{
    if (argc < 2)
        return EXIT_FAILURE;
    NSString *sourceURLString = [NSString stringWithCString:argv[1]];
    NSData *data = [[NSData alloc] initWithContentsOfURL:[NSURL URLWithString:sourceURLString]];
    NSLog(@"%@", [data base64String]);
    return EXIT_SUCCESS;
}
</source>
The dispatcher will find both methods called over the NSData instance and invoke both of them correctly.

=== Uninstantiable ===
'''Uninstantiable classes''' allow programmers to group together per-class fields and methods that are accessible at runtime without an instance of the class. Indeed, instantiation is prohibited for this kind of class.

For example, in C#, a class marked "static" can not be instantiated, can only have static members (fields, methods, other), may not have ''instance constructors'', and is ''sealed''.
<ref>{{cite web
 | url=http://msdn.microsoft.com/en-us/library/79b3xss3(v=vs.100).aspx
 | title=Static Classes and Static Class Members (C# Programming Guide)
 | work=C# Programming Guide
 | publisher=Microsoft
 | accessdate=2012-05-08}}
</ref>

=== Unnamed ===
An '''unnamed class''' or '''anonymous class''' is a class which is not bound to a name or identifier upon definition. This is analogous to named versus [[anonymous function|unnamed functions]].

== Benefits ==
{{weasel|section|date=April 2012}}
{{Unreferenced section|date=April 2012}}

Computer programs usually model aspects of some real or abstract world (the [[Domain-driven design|Domain]]). Because each class models a concept, classes provide a more natural way to create such models. Each class in the model represents a noun in the domain, and the methods of the class represent verbs that may apply to that noun (Verbs can also be modeled as classes, see [[Command pattern|Command Pattern]]). For example in a typical business system, various aspects of the business are modeled, using such classes as ''Customer'', ''Product'', ''Worker'', ''Invoice'', ''Job'', etc. An ''Invoice'' may have methods like ''Create'', ''Print'' or ''Send'', a ''Job'' may be ''Performed'' or ''Canceled'', etc. Once the system can model aspects of the business accurately, it can provide users of the system with useful information about those aspects. Classes allow a clear correspondence ([[map (mathematics)|mapping]]) between the model and the domain, making it easier to design, build, modify and understand these models. Classes provide some control over the often challenging complexity of such models.

Classes can accelerate development by reducing redundant program code, [[Software testing|testing]] and [[Software bug|bug]] [[Debugging|fixing]]. If a class has been thoroughly tested and is known to be a 'solid work', it is usually true that using or extending the well-tested class will reduce the number of bugs - as compared to the use of freshly developed or ad hoc code - in the final output. In addition, efficient class reuse means that many bugs need to be fixed in only one place when problems are discovered.

Another reason for using classes is to simplify the relationships of interrelated data. Rather than writing code to repeatedly call a [[graphical user interface]] (GUI) [[Window (computing)|window]] drawing subroutine on the terminal screen (as would be typical for [[structured programming]]), it is more intuitive. With classes, GUI items that are similar to windows (such as dialog boxes) can simply inherit most of their functionality and data structures from the [[window class]]. The programmer then need only add code to the dialog class that is unique to its operation. Indeed, GUIs are a very common and useful application of classes, and GUI programming is generally much easier with a good class framework.

== Run-time representation ==
{{Unreferenced section|date=May 2012}}

As a data type, a class is usually considered as a compile-time construct. A language may also support [[prototype]] or [[Factory method pattern|factory]] [[metaobject]]s that represent run-time information about classes, or even represent metadata that provides access to [[Reflection (computer science)|reflection]] facilities and ability to manipulate data structure formats at run-time. Many languages distinguish this kind of [[run-time type information]] about classes from a class on the basis that the information is not needed at run-time. Some dynamic languages do not make strict distinctions between run-time and compile-time constructs, and therefore may not distinguish between metaobjects and classes. 

For example, if Human is a [[metaobject]] representing the class Person, then instances of class Person can be created by using the facilities of the Human [[metaobject]].

== See also ==
* [[Object-oriented programming]]
* [[Class-based programming]]
* [[Prototype-based programming]]
* [[Class diagram]] (UML)
* [[List of object-oriented programming languages]]

== Notes ==
{{reflist}}

== References ==
* {{cite book
 | ref = harv
 | last = Booch
 | first = Grady
 | year = 1994
 | title = Objects and Design with Applications, Second Edition
 | publisher = Benjamin/Cummings
}}

* {{cite book
 | ref = harv
 | last = Gamma
 | last2 = Helm
 | last3 = Johnson
 | last4 = Vlissides
 | year = 1995
 | title = Design Patterns: Elements of Reusable Object-Oriented Software
 | publisher = Addison Wesley
}}

== Further reading ==
* [http://lucacardelli.name/TheoryOfObjects.html Abadi; Cardelli: A Theory of Objects]
* [http://www.open-std.org/jtc1/sc22/wg21/ ISO/IEC 14882:2003 Programming Language C++, International standard]
* [http://www.laputan.org/reflection/warfare.html Class Warfare: Classes vs. Prototypes], by Brian Foote
* Meyer, B.: "Object-oriented software construction", 2nd edition, Prentice Hall, 1997, ISBN 0-13-629155-4
* Rumbaugh et al.: "Object-oriented modeling and design", Prentice Hall, 1991, ISBN 0-13-630054-5

== External links ==
* {{cite web| title=Programming demo - .NET using Partial Types for better code | url=http://www.youtube.com/watch?v=oaw8K8GNhAI | work=Hyper/Net | publisher=Youtube| month=October| year=2006| last=Dias| first=Tiago}}

{{Programming language}}
{{Data types}}

{{DEFAULTSORT:Class (Computer Programming)}}
[[Category:Programming constructs]]
[[Category:Object-oriented programming]]
[[Category:Programming language topics]]
[[Category:Class (computer programming)| ]]